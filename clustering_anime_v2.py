# -*- coding: utf-8 -*-
"""Clustering_Anime_V2.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1vHPaOrmXZ9hBoABzGUGMAuep4RI-chkW

# 1.Connect Google Drive
"""

from google.colab import drive
drive.mount('/content/drive')

import os
default_dir = "/content/drive/MyDrive/Colab Notebooks/Final_project_vector_team"
os.chdir(default_dir)

!ls

"""# 2.Import Library"""

# Commented out IPython magic to ensure Python compatibility.
# Library
import numpy as np
import pandas as pd
import sklearn

#library visualisasi
import matplotlib.pyplot as plt
import seaborn as sns

import warnings
warnings.filterwarnings("ignore")
# %matplotlib inline
sns.set(rc={"figure.figsize": (20, 15)}) # panjang 2o lebar 15
sns.set_style("whitegrid")

from sklearn.metrics import silhouette_score
from sklearn.cluster import KMeans
from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.preprocessing import MinMaxScaler
from sklearn.metrics import silhouette_score

from sklearn.preprocessing import RobustScaler
from sklearn.neighbors import KNeighborsClassifier
from sklearn.svm import SVC
from sklearn.tree import DecisionTreeClassifier
from sklearn.linear_model import LogisticRegression

#ensemble : terdiri dari beberapa model
from sklearn.ensemble import (
    GradientBoostingClassifier,
    RandomForestClassifier
)

from sklearn.metrics import (
    accuracy_score,
    roc_auc_score,
    roc_curve,
    classification_report
)

from sklearn.model_selection import (
    KFold,
    train_test_split,
    GridSearchCV,
    cross_val_score
)

"""# 3.Load Dataset"""

# Load Dataset
df = pd.read_csv("assets/mal_anime.csv")
print(f"Dataset shape:\n{df.shape}\n")

"""# 4.EDA

Depent varaibel = Demographic
"""

df.head()

df.tail()

shape = df.shape
print(shape)

df.info()

df.describe()

df.demographic.unique()

# Target variable categorical
df.demographic.value_counts()

"""# 5.Data Processing

##5.1 Delete Coloms
"""

# Hapus kolom-kolom
kolom_yang_di_hapus = ['Unnamed: 0', 'status', 'synopsis', 'episodes', 'premiered', 'members', 'aired']
df.drop(columns=kolom_yang_di_hapus, inplace=True)


# Tampilkan DataFrame setelah menghapus kolom
print(df)

df.duplicated().sum()

df.drop_duplicates(inplace=True)

def columns_info(df):
  cols=[]
  dtypes=[]
  nunique=[]
  nulls=[]
  for col in df.columns:
    cols.append(col)
    dtypes.append(df[col].dtypes)
    nunique.append(df[col].nunique())
    nulls.append(df[col].isna().sum())
  return pd.DataFrame({'Columns' : cols,
                       'Data Types' : dtypes,
                       'Numbers of Unique' : nunique,
                       'Numbers of Nulls' : nulls})
columns_info(df)

df.info()

# Menghitung jumlah <NA> pada kolom 'score'
na_count_score = df['score'].isna().sum()
na_count_rank = df['rank'].isna().sum()

print("Jumlah <NA> pada kolom 'score':", na_count_score)
print("Jumlah <NA> pada kolom 'rank':", na_count_rank)

# Menghapus baris dengan nilai NaN pada kolom 'rank' dan 'score
df = df.dropna(subset=['score'])
df = df.dropna(subset=['rank'])

df.studios.value_counts()

# Mengubah "None Found" menjadi NaN
df['studios'] = df['studios'].replace('None found, add some', pd.NA)

# Filter data untuk mengabaikan baris dengan nilai NaN di kolom 'studio'
df_filtered = df.dropna(subset=['studios'])

"""##5.2 Change Data Type"""

# Remove commas and convert 'favorit' column to integer data type
df['favorites'] = df['favorites'].apply(lambda x: int(str(x).replace(',', '')))

#popularity
df['popularity'] = df['popularity'].apply(lambda x: int(str(x).replace('#', '')))

# rank
df['rank'] = df['rank'].apply(lambda x: int(str(x).replace('#', '')))

df.info()

# durasi

def convert_to_hours(duration_str):
    parts = duration_str.split()
    hours = 0

    for i in range(len(parts)):
        if parts[i] == "hr.":
            hours = int(parts[i-1])

    return hours

# Menambahkan kolom "duration(hours)"
df["duration(hours)"] = df["duration"].apply(convert_to_hours)

# Ubah jam ke menit
df["duration(m)"] = df["duration"].apply(convert_to_hours)*60
print(df[['duration(hours)', 'duration(m)']])

# Fungsi untuk mengonversi format "1 hr. 24 min. per ep." menjadi menit
def convert_to_minutes(duration_str):
    parts = duration_str.split()
    minutes = 0

    for i in range(len(parts)):
        if parts[i] == "min.":
            minutes = int(parts[i-1])

    return minutes

# Memanggil fungsi untuk mengonversi ke menit
df["duration(minute)"] = df["duration"].apply(convert_to_minutes)

# Menambahkan kolom baru 'duration_eps(minutes)'
df.insert(df.columns.get_loc('duration')+1, 'duration_eps(minutes)', df['duration(m)'] + df['duration(minute)'])

#hapus kolom yang tidak digunakan lagi
# kolom 'duration', 'duration(hours), dan duration('minute')

df.drop(columns=['duration', 'duration(hours)','duration(m)',
               'duration(minute)'],inplace=True)

# Mengubah "Unknown" menjadi "Semua Umur" di kolom 'demographic'
df['demographic'] = df['demographic'].replace('Unknown', 'Semua Umur')

df.hist(figsize = (20,10))

df.describe()

"""**CEK KEANEHAN**

1. Favorites dan duration_eps(minutes) = 0

## 5.3 Delete or Fill Uknown
"""

cols = ["favorites", "popularity", "rank", "duration_eps(minutes)"]
for col in cols:
    df[col].replace(0, np.NaN, inplace=True)

# now we can see missing values
df.isnull().sum()

df = df.dropna(subset=['favorites', 'duration_eps(minutes)', 'studios'])

# now we can see missing values
df.isnull().sum()

df.describe()

df.info()

# Fungsi untuk memeriksa apakah suatu nilai adalah angka
def is_numeric(value):
    try:
        float(value)
        return True
    except ValueError:
        return False

# Menggunakan fungsi is_numeric untuk memeriksa setiap elemen dalam kolom 'favorites'
non_numeric_data = df['favorites'].apply(lambda x: not is_numeric(x))

# Menampilkan hasil
print("Data non-angka pada kolom 'favorites':")
print(df[non_numeric_data])

"""# 6.Visualisasi"""

# 1. Heat Map
plt.figure(figsize=(10, 5))

sns.heatmap(
    df.corr(),
    cmap='Pastel1',
    annot=True
);

# Top 10 genres
top_ranked = df.nsmallest(10, 'rank')[['title', 'rank']]
plt.figure(figsize=(10, 6))
sns.barplot(x='rank', y='title', data=top_ranked, palette='pastel')
plt.title('Top 10 Highest Ranked Anime')

#Distribution of demographics
plt.figure(figsize=(10, 6))


sns.countplot(y='demographic', data=df, order=df['demographic'].value_counts().index, palette='pastel')
plt.title('Distribution of Demographics')

#Top 10 studios with most anime produced

top_studios = df['studios'].value_counts().nlargest(10)

plt.figure(figsize=(10, 6))
sns.barplot(x=top_studios.values, y=top_studios.index, palette='pastel')

plt.title('Top 10 Studios With Most Anime Produced')

# Menampilkan chart
plt.show()

#7. Relation between members and score
plt.figure(figsize=(10, 6))
sns.scatterplot(x='duration_eps(minutes)', y='demographic', data=df)
plt.title('Relation Between Duration and Demographic')

"""#7.Feature Engginering"""

# Tentukan nilai max dan min dari kolom 'rank'
nilai_max_r = df['rank'].max()
nilai_min_r = df['rank'].min()

# Tentukan jumlah bins yang Anda inginkan
jumlah_bins = 3  # Ganti dengan jumlah bins yang Anda inginkan

# Hitung lebar setiap bins berdasarkan rentang nilai max dan min
lebar_bins = (nilai_max_r - nilai_min_r) / jumlah_bins

# Buat array dari batas-batas bins
batas_bins = [nilai_min_r + i * lebar_bins for i in range(jumlah_bins+1)]

# Tampilkan batas-batas bins
print("Batas-batas bins:", batas_bins)

df['rank_range'] = pd.cut(
    x=df['rank'],
    bins=[0, 4271, 8542, 12813],
    labels=["low", "moderate", "high"]
)

df['score_range'] = pd.cut(
    x=df['score'],
    bins=[0, 4.2, 6.6, 9.1],
    labels=["bad", "good", "excellent"]
)

df['popularity_range'] = pd.cut(
    x=df['popularity'],
    bins=[0, 6177, 12353, 18529],
    labels=["unpopular", "popular", "very popular"]
)

df['favorites_range'] = pd.cut(
    x=df['favorites'],
    bins=[0, 109139, 218277],
    labels=["no", "yes"]
)

df.head()

"""##7.1 One-hot encoding"""

df.head(5)

df_new = df.copy()

# Membuat objek LabelEncoder
encoder = LabelEncoder()

# Menggunakan LabelEncoder untuk mengubah nilai kategori menjadi bilangan bulat
df_new['demograpic_encoded'] = encoder.fit_transform(df_new['demographic'])

# Menampilkan DataFrame hasil
print(df_new)

df_new.head()

"""#7.2 Scalling"""

# Menampilkan box plot dari DataFrame yang telah di-standarisasi
plt.figure(figsize=(15, 5))
sns.boxplot(data=df_new)
plt.title('Box Plot of Standardized Numeric Columns')
plt.show()

"""### 1.Numeric"""

# Mengambil semua kolom dengan tipe data numerik
numeric_columns = df_new.select_dtypes(include='number')

# Menghilangkan kolom non-numerik dari DataFrame
df_numeric = df_new[numeric_columns.columns]

# Standarisasi data numerik menggunakan StandardScaler
scaler = StandardScaler()
df_std = scaler.fit_transform(df_numeric)
df_std = pd.DataFrame(data=df_std, index=df_new.index, columns=numeric_columns.columns)

print(df_std)

# Menampilkan box plot dari DataFrame yang telah di-standarisasi
plt.figure(figsize=(15, 5))
sns.boxplot(data=df_std)
plt.title('Box Plot of Standardized Numeric Columns')
plt.show()

"""### 2.Category"""

categorical_columns = df_new.select_dtypes(include='category').columns.tolist()

print(categorical_columns)

# Convert categorical_columns to the underlying data type (object) before slicing
df_encode = df[categorical_columns].copy()

for col in categorical_columns:
    df_encode[col] = LabelEncoder().fit_transform(df_encode[col])

df_model= df_encode.merge(df_std, left_index = True, right_index=True, how= 'left')
print(df_model.head(10))

# Menampilkan box plot dari DataFrame yang telah di-standarisasi
plt.figure(figsize=(16, 5))
sns.boxplot(data=df_model)
plt.title('Box Plot of Standardized Numeric Columns')
plt.show()

"""# 8.Modeling"""

import warnings
warnings.simplefilter(action='ignore', category=FutureWarning)

# Modeling
'''
possible_k = [2, 3, 4, 5, 6, 7, 8, 9, 10]
silhouette = []

for k in possible_k:
    kmeans = KMeans(n_clusters=k, random_state=42).fit(df_std)
    silhouette.append(silhouette_score(X=df_std, labels=kmeans.labels_))

'''

# Modeling
range_clusters = list(range(2, 16))
inertia = []

for k in range_clusters:
    kmeans = KMeans(n_clusters=k)
    kmeans.fit(df_model)
    inertia.append(kmeans.inertia_)

plt.figure(figsize=(10, 4))
plt.plot(range_clusters, inertia, marker='o', linestyle='-', color='blue')

elbow_point = (range_clusters[2], inertia[2])

# Menambahkan label pada elbow point
plt.annotate('Elbow Point', xy=elbow_point, xytext=(elbow_point[0] + 0.5, elbow_point[1] + 10),
             arrowprops=dict(facecolor='black', arrowstyle='->'),
             fontsize=12)

plt.xticks(range_clusters)
plt.title('Elbow Method')
plt.xlabel('Number of Clusters')
plt.ylabel('Inertia')
plt.show()

kmeans = KMeans(
    n_clusters=4,
    random_state=42).fit(df_std)

df_result_kmeans = df_new.copy()
df_result_kmeans['cluster'] = kmeans.labels_

sns.pairplot(
    data=df_result_kmeans,
    hue='cluster',
    diag_kind='None',
    palette='tab10'
)

plt.show();

# Mendapatkan label kluster untuk setiap baris
labels = kmeans.labels_

# Menampilkan 20 baris teratas dari DataFrame df_kmeans
print(df_result_kmeans.head(5))

# Menampilkan hasil statistik
print("Cluster Centers:")
print(kmeans.cluster_centers_)

print("Labels:")
print(kmeans.labels_)

print("Inertia:")
print(kmeans.inertia_)

print("Number of Clusters:")
print(kmeans.n_clusters)

# Quantile function
def q25(x):
    return x.quantile(0.25)

def q75(x):
    return x.quantile(0.75)

# Simple descriptive statistic
result_stats = (
    df_result_kmeans
    .drop("demograpic_encoded", axis=1)  # Menghilangkan kolom 'Country_UK' jika ada
    .groupby('cluster')
    .agg(['mean', 'std', 'min', q25, 'median', q75, 'max'])
)

# Menampilkan hasil statistik
print(result_stats.transpose())

"""**Analisa**

Cluster 0:

1. favorites = min: 1 max: 4509
2. popularity = min: 175 max: 18529
3. rank = min: 2491 max: 12813
4. score = min: 1 max: 7.3
5. duration_eps(minutes) = min: 1 max:119

Cluster 1:

1. favorites = min: 41929 max: 218277
2. popularity = min: 1 max: 140
3. rank = min: 1 max: 3056
4. score = min: 7.2 max: 9.1
5. duration_eps(minutes) = min: 22 max: 130


Cluster 2:

1. favorites = min: 1 max: 38182
2. popularity = min: 12 max: 12277
3. rank = min: 3 max: 8629
4. score = min: 6 max: 9
5. duration_eps(minutes) = min: 1 max: 64


Cluster 3:

1. favorites =  min: 1 max: 31310
2. popularity =  min: 44 max: 14116
3. rank =  min: 9 max:  11990
4. score =  min: 5 max: 9
5. duration_eps(minutes) = min: 54 max: 168

"""

plt.figure(figsize=(10, 4))
sns.countplot(data=df_result_kmeans, x='cluster', hue='demographic')
plt.title('Count Plot by Cluster and Type')
plt.show()

scaler = MinMaxScaler()
X = df_model
X = scaler.fit_transform(X)

from scipy.cluster.hierarchy import linkage, dendrogram

mergings = linkage(X, method='ward')
plt.figure(figsize= (12, 6))
dendrogram(mergings)
plt.axhline(y=3, color = 'r', linestyle = '--')
plt.show()

# Pilih kluster tertentu (misalnya kluster 1)
cluster_number = 0
cluster_films = df_result_kmeans[df_result_kmeans['cluster'] == cluster_number]

# Menampilkan 10 film terbaik dalam kluster
top_10_films = cluster_films.nlargest(10, 'score')
print(top_10_films)

# Pilih kluster tertentu (misalnya kluster 1)
cluster_number = 1

# Pilih film dengan skor terbaik dalam kluster
best_film_cluster = df_result_kmeans[df_result_kmeans['cluster'] == cluster_number].nlargest(1, 'score')

# Menampilkan film dengan skor terbaik dalam kluster
print("Film dengan skor terbaik dalam kluster", cluster_number)
print(best_film_cluster)

"""8. Streamlit"""

# Menampilkan barchart untuk film dengan skor terbaik dalam kluster
st.title('Film dengan Skor Terbaik di Kluster ' + str(cluster_number))
st.bar_chart(best_film_cluster.set_index('title'))

"""#9.Streamlit"""

from sklearn.cluster import KMeans
import matplotlib.pyplot as plt
import streamlit as st

df_new.head()

# Title of the app
st.title('Aplikasi Analisis Data Anime')

# Display the cluster data (replace 'df_result_kmeans' with your cluster data)
st.header('Cluster Anime')
st.dataframe(df_result_kmeans)


# Additional information
st.write('Pilih jumlah kluster berdasarkan titik "elbow" pada grafik Elbow Method.')

streamlit run Clustering_Anime_V2.py